{"pages":[{"title":"Categories","date":"2021-03-17T06:50:19.970Z","path":"categories/index.html","text":""},{"title":"About","date":"2021-03-17T06:50:19.930Z","path":"about/index.html","text":""},{"title":"Tags","date":"2021-03-17T06:50:20.006Z","path":"tags/index.html","text":""}],"posts":[{"title":"2021-03-15 需求","date":"2021-03-17T06:20:27.718Z","path":"wiki/Work/2021-03-15 需求/","text":"2021-03-15 需求 刘—1 2 7 箱子– 还箱时长 &amp; 还箱状态 &amp; 箱子信息”中增加字段“EIR状态 刘—6 11 订单状态 刘—13 忘记密码功能 黄—3 5 9 下拉查询 新增 “首字母拼音”搜索 黄—10 14 15 新建订单 匹配问题 数据复制 预录匹配规则 黄—17 打印 ​ 4 放箱端委托同行业务 8 分段预审","tags":[],"categories":[{"name":"Work","slug":"Work","permalink":"http://example.com/categories/Work/"}]},{"title":"简历","date":"2021-03-17T06:20:27.705Z","path":"wiki/Resume/简历/","text":"简历 简历通发 针对公司业务修改自己简历 模拟自测/面试-重要 坑点 盲目跟风，夸大其词，自负，细节决定成败 渠道 内推，朋友介绍，职业猎头 行业 前景，同行的的评价，生态 todolist","tags":[],"categories":[{"name":"Resume","slug":"Resume","permalink":"http://example.com/categories/Resume/"}]},{"title":"框架对比","date":"2021-03-17T06:20:27.694Z","path":"wiki/Javascript/框架对比/","text":"vue和react的区别虚拟DOM：vue：计算出虚拟DOM的差异，在渲染的过程中跟踪每个组件的依赖关系，不会重新渲染整个组件树react：当应用的状态改变时，重新渲染全部子组件，可以通过shouldComponentUpdate生命周期进行优化 模板和jsx：vue：具有单文件组件，可以把html、css、js写在一个vue文件里—-MVVM框架react：依赖于jsx，在JavaScript中创建DOM—-视图层框架 数据绑定vue是响应式的数据双向绑定系统，而react是单向数据流，没有双向绑定。 应用vue的语法较为简单，适用于小型项目创建，而react更适用于Web端和原生App的开发，侧重于大型应用。组件写法不一样react推荐的做法是JSX+inline style,也就是把HTML和CSS全都写进javaScript了 state对象state对象在react应用中是不可变的，需要使用setState方法更新状态在vue中，state对象不是必须的，数据有data属性在vue对象中管理 模板渲染方式的不同在表层上，模板的语法不同，React是通过JSX渲染模板。而Vue是通过一种拓展的HTML语法进行渲染，但其实这只是表面现象，毕竟React并不必须依赖JSX。在深层上，模板的原理不同，这才是他们的本质区别：React是在组件JS代码中，通过原生JS实现模板中的常见语法，比如插值，条件，循环等，都是通过JS语法实现的，更加纯粹更加原生。而Vue是在和组件JS代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 v-if 来实现对这一点，这样的做法显得有些独特，会把HTML弄得很乱。举个例子，说明React的好处：react中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以我们import 一个组件完了之后，还需要在 components 中再声明下，这样显然是很奇怪但又不得不这样的做法。react会把一个简单的组件分成了好多份。就像说的单向数据流，每个组件是在”取公用的顶层资源“来解决问题。vue是获取少量的”顶层资源“，实现业务独立性，某种意义上，vue更注重业务逻辑的解耦，react更注重代码是面向对象的。 react是教组件你怎么做，vue是告诉你要做的功能，一个像领导指手画脚给你东西处理，另一个是告诉你他想要什么，你直接告诉领导结果。vue是分配任务制的。 对比总结：1、如果你喜欢简洁，喜欢组件业务解耦，喜欢把重复的事情交给自带的，不喜欢一大堆的全局状态（vue有时候甚至不需要全局状态），那么你就选择vue，它的思想就是把一些事情规范起来，让组件足够独立。2、如果你觉得你更喜欢纯粹的语言风格，那react就是为这个而生的，jsx就是很好的例子，它所有思想其实都是为了让你纯粹的写一个个类（组件），这就意味着有些东西你需要自己来，响应的实现某一个事情，你需要的插件也不少，一个相同的项目，我用vue重新写一遍，插件是react的1/3","tags":[],"categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://example.com/categories/Javascript/"}]},{"title":"typescript","date":"2021-03-17T06:20:27.690Z","path":"wiki/Javascript/typescript/","text":"编程语言的类型 * 动态类型语言(运行的时候 数据类型检查) * 静态类型语言(编译的时候 数据类型检查) 为什么使用 * 程序更容易理解 &gt;代码就是注释 * 效率更高 &gt;代码补全 代码跳转 接口提示 * 更少的错误 &gt;编译时期能够发现错误 * 非常好的包容性 &gt;第三方库支持 缺点 * 学习成败 &amp; 短期开发成本 interface * 对 对象的形状进行描述 shape * 对类 进行抽象 class * 鸭子类型 duck typing class * class 定义了一切事物的抽象特点 * object 类的实例 * 面向对象 oop 三大特性：封装 继承 多态 public 是公有的，可修改，可读取的private 属性“name”为私有属性，只能在类“Animal”中访问protected 属性“name”受保护，只能在类“Animal”及其子类中访问。readonly 只读属性static 和创建的动态实例没有关系，是类自己特有的属性方法interface 定义约束内容 用implements方法 抽象类的属性和方法，定义函数的类型generics * 定义函数接口或者类的时候，不先指定类型，使用的时候再指定类型 * 占位符，变量，约束 * 约束泛型 用 extends 继承 interface type aliases //类型别名type assertion //类型断言","tags":[],"categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://example.com/categories/Javascript/"}]},{"title":"React","date":"2021-03-17T06:20:27.686Z","path":"wiki/Javascript/React/","text":"VUE双向绑定，强调在不同组件中同步状态REACT 只有单一数据源（状态提升和单向数据流），在应用中保持自上而下的数据流，在有数据源的地方做综合处理 npx 调用包里的某个模块 npm run 会新建一个shell执行脚本命令，将node_modules 模块加入path变量，执行结束后将path命令恢复原样 React Hook 使用函数式组件代替class组件的写法（没有破坏性改动 / 百分之百向后兼容 / 完全可选 / 没有计划移除Class） 组件很难复用状态逻辑 业务复杂难以理解，尤其是生命周期 React 组件一直是函数，使用Hook完全拥抱函数 Effect Hook react 更新DOM后：发送一个网络请求，主动变更DOM，记录日志） 无需清除的effect 需要清除的effect 在下一次的render后 remove effect","tags":[],"categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://example.com/categories/Javascript/"}]},{"title":"koa","date":"2021-03-17T06:20:27.682Z","path":"wiki/Javascript/koa/","text":"什么是koa koa是一个新的WEB框架 利用async函数丢弃回调函数，增强错误处理。（使用同步的写法去执行异步的函数） 没有任何预置的中间件 koa核心概念 koa Application(应用程序) Context (上下文) request（请求）、response (相应) koa核心概念 洋葱模型执行的顺序：顺序执行 回调的顺序：反向执行 先进后出 koa中间件 路由：koa-router 协议解析： koa-body 跨域处理： @koa/cors 路由压缩： koa-combine-routers 静态资源： koa-static","tags":[],"categories":[{"name":"Javascript","slug":"Javascript","permalink":"http://example.com/categories/Javascript/"}]},{"title":"书签","date":"2021-03-17T06:20:27.671Z","path":"wiki/Daily/书签/","text":"Javascript 中数据类型那些可能会中招的细节https://mp.weixin.qq.com/s/zf981TL50USDRyBUdAYMyA 冴羽的博客https://github.com/mqyqingfeng/Blog JavaScript深入之从原型到原型链https://github.com/mqyqingfeng/Blog/issues/2 前端年后面试真题，会80%直接进大厂https://bitable.feishu.cn/app8Ok6k9qafpMkgyRbfgxeEnet?from=logout&amp;table=tblLUxZFqOA2vI2F&amp;view=vew0lbb2R4 面经https://juejin.im/post/5e8d5a48f265da47ce6cb21f","tags":[],"categories":[{"name":"Daily","slug":"Daily","permalink":"http://example.com/categories/Daily/"}]},{"title":"use","date":"2021-03-17T06:20:27.666Z","path":"wiki/Daily/use/","text":"this.$set(v, ‘aaa’, ‘’) Object.assign(this.$data.form, this.$options.data().form)Object.assign(this.$data, this.$options.data()) // 重置data对象到初始化状态 finally().catch(error =&gt; { this.$message.error(error.msg)}) { min: 3, max: 32, message: ‘长度在 3 到 32 个字符’, trigger: ‘blur’ }{ validator(r, v, b) { (/(^[1-9]\\d*$)/).test(v) ? b() : b(new Error(‘ ‘)) } }","tags":[{"name":"aa","slug":"aa","permalink":"http://example.com/tags/aa/"}],"categories":[{"name":"Daily","slug":"Daily","permalink":"http://example.com/categories/Daily/"}]}],"categories":[{"name":"Work","slug":"Work","permalink":"http://example.com/categories/Work/"},{"name":"Resume","slug":"Resume","permalink":"http://example.com/categories/Resume/"},{"name":"Javascript","slug":"Javascript","permalink":"http://example.com/categories/Javascript/"},{"name":"Daily","slug":"Daily","permalink":"http://example.com/categories/Daily/"}],"tags":[{"name":"aa","slug":"aa","permalink":"http://example.com/tags/aa/"}]}